//! Manage remote configuration.

use std::error::Error as _;

use anyhow::{bail, format_err, Error};
use serde::{Deserialize, Serialize};

use proxmox_access_control::CachedUserInfo;
use proxmox_router::{
    http_bail, http_err, list_subdirs_api_method, Permission, Router, RpcEnvironment, SubdirMap,
};
use proxmox_rrd_api_types::RrdMode;
use proxmox_rrd_api_types::RrdTimeframe;
use proxmox_schema::api;
use proxmox_schema::Schema;
use proxmox_section_config::typed::SectionConfigData;
use proxmox_sortable_macro::sortable;
use proxmox_time::{epoch_i64, epoch_to_rfc2822};

use pdm_api_types::remotes::{Remote, RemoteType, RemoteUpdater, REMOTE_ID_SCHEMA};
use pdm_api_types::rrddata::RemoteDatapoint;
use pdm_api_types::{Authid, ConfigDigest, PRIV_RESOURCE_AUDIT, PRIV_RESOURCE_MODIFY};

use crate::metric_collection;
use crate::{connection, pbs_client};

use super::pve;
use super::rrd_common;
use super::rrd_common::DataPoint;

pub const ROUTER: Router = Router::new()
    .get(&API_METHOD_LIST_REMOTES)
    .post(&API_METHOD_ADD_REMOTE)
    .match_all("id", &ITEM_ROUTER);

const ITEM_ROUTER: Router = Router::new()
    .put(&API_METHOD_UPDATE_REMOTE)
    .delete(&API_METHOD_REMOVE_REMOTE)
    .get(&list_subdirs_api_method!(SUBDIRS))
    .subdirs(SUBDIRS);

#[sortable]
const SUBDIRS: SubdirMap = &sorted!([
    ("config", &Router::new().get(&API_METHOD_REMOTE_CONFIG)),
    ("version", &Router::new().get(&API_METHOD_VERSION)),
    (
        "rrddata",
        &Router::new().get(&API_METHOD_GET_PER_REMOTE_RRD_DATA)
    ),
]);

pub fn get_remote<'a>(
    config: &'a SectionConfigData<Remote>,
    id: &str,
) -> Result<&'a Remote, Error> {
    config
        .get(id)
        .ok_or_else(|| http_err!(NOT_FOUND, "no such node '{id}'"))
}

#[api(
    access: {
        permission: &Permission::Anybody,
        description: "Returns the resources the user has access to.",
    },
    returns: {
        description: "The list of configured remotes.",
        type: Array,
        items: {
            description: "Remote entry",
            type: Object,
            properties: {},
        },
    },
)]
/// List all the remotes this instance is managing.
pub fn list_remotes(rpcenv: &mut dyn RpcEnvironment) -> Result<Vec<Remote>, Error> {
    let auth_id: Authid = rpcenv
        .get_auth_id()
        .ok_or_else(|| format_err!("no authid available"))?
        .parse()?;
    let user_info = CachedUserInfo::new()?;
    let top_level_allowed = 0 != user_info.lookup_privs(&auth_id, &["resource"]);

    let (remotes, digest) = pdm_config::remotes::config()?;
    rpcenv["digest"] = digest.to_hex().into();

    Ok(remotes
        .into_iter()
        .filter_map(|(id, mut value)| {
            // FIXME: proper type here?
            value.token = String::new(); // remove secret from api response
            (top_level_allowed || 0 != user_info.lookup_privs(&auth_id, &["resource", &id]))
                .then_some(value)
        })
        .collect())
}

const CREATE_TOKEN_SCHEMA: Schema = pdm_api_types::PROXMOX_TOKEN_NAME_SCHEMA
    .unwrap_string_schema_cloned()
    .description("If given, create this token on the remote and use it.")
    .schema();

// FIXME: need to have a type spanning all remote types here... SOMEHOW... (eg. oneOf support)
#[api(
    input: {
        properties: {
            entry: {
                flatten: true,
                type: Remote,
            },
            "create-token": {
                optional: true,
                schema: CREATE_TOKEN_SCHEMA,
            },
        },
    },
    access: {
        permission: &Permission::Privilege(&["resource"], PRIV_RESOURCE_MODIFY, false),
    },
)]
/// List all the remotes this instance is managing.
pub async fn add_remote(mut entry: Remote, create_token: Option<String>) -> Result<(), Error> {
    let _lock = pdm_config::remotes::lock_config()?;
    let (mut remotes, _) = pdm_config::remotes::config()?;

    if remotes.contains_key(&entry.id) {
        bail!("entry {:?} already exists", entry.id);
    }

    if let Some(create_token) = create_token {
        let nodename = proxmox_sys::nodename();
        let date = epoch_to_rfc2822(epoch_i64())?;
        let comment = Some(format!("auto-generated by PDM host '{nodename}' on {date}"));

        /// With the `Client`'s error type the message gets a bit long, shorten it:
        fn short_create_err(err: proxmox_client::Error) -> Error {
            format_err!("error creating token: {}", err.source().unwrap_or(&err))
        }

        // connect to remote and try to create a token
        let (authid, token) = match entry.ty {
            RemoteType::Pve => {
                let client = pve::connect_or_login(&entry).await?;

                let user = entry.authid.user();

                let token = client
                    .create_token(
                        &user.to_string(),
                        &create_token,
                        pve_api_types::CreateToken {
                            comment,
                            expire: None,
                            privsep: Some(false),
                        },
                    )
                    .await
                    .map_err(short_create_err)?;
                (token.full_tokenid.parse()?, token.value)
            }
            RemoteType::Pbs => {
                let client = pbs_client::connect_or_login(&entry).await?;

                let token = client
                    .create_token(
                        &entry.authid.to_string(),
                        &create_token,
                        pbs_client::CreateToken {
                            comment,
                            enable: Some(true),
                            expire: None,
                        },
                    )
                    .await
                    .map_err(short_create_err)?;
                (token.tokenid.parse()?, token.value)
            }
        };
        entry.authid = authid;
        entry.token = token;
    }

    let name = entry.id.clone();
    remotes.insert(entry.id.to_owned(), entry);

    pdm_config::remotes::save_config(&remotes)?;

    if let Err(e) = metric_collection::trigger_metric_collection(Some(name), false).await {
        log::error!("could not trigger metric collection after adding remote: {e}");
    }

    Ok(())
}

#[api()]
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
/// Deletable property name
pub enum DeletableProperty {
    /// Delete the web-url property.
    WebUrl,
}

// FIXME: Support `OneOf` in schema so we can use a derived Updater for all product types?
// Otherwise we need to have a custom updater struct that covers all product remotes.
#[api(
    input: {
        properties: {
            id: { schema: REMOTE_ID_SCHEMA },
            updater: {
                flatten: true,
                type: RemoteUpdater,
            },
            delete: {
                description: "List of properties to delete.",
                type: Array,
                optional: true,
                items: {
                    type: DeletableProperty,
                }
            },
            digest: {
                optional: true,
                type: ConfigDigest,
            },
        },
    },
    access: {
        permission: &Permission::Privilege(&["resource", "{id}"], PRIV_RESOURCE_MODIFY, false),
    },
)]
/// List all the remotes this instance is managing.
pub fn update_remote(
    id: String,
    updater: RemoteUpdater,
    delete: Option<Vec<DeletableProperty>>,
    digest: Option<ConfigDigest>,
) -> Result<(), Error> {
    let (mut remotes, config_digest) = pdm_config::remotes::config()?;
    config_digest.detect_modification(digest.as_ref())?;

    let entry = remotes
        .get_mut(&id)
        .ok_or_else(|| http_err!(NOT_FOUND, "no such remote {id:?}"))?;

    if let Some(delete) = delete {
        for delete_prop in delete {
            match delete_prop {
                DeletableProperty::WebUrl => {
                    entry.web_url = None;
                }
            }
        }
    }

    if let Some(v) = updater.nodes {
        entry.nodes = v;
    }
    if let Some(v) = updater.authid {
        entry.authid = v;
    }
    if let Some(v) = updater.token {
        entry.token = v;
    }

    if updater.web_url.is_some() {
        entry.web_url = updater.web_url;
    }

    pdm_config::remotes::save_config(&remotes)?;

    Ok(())
}

#[api(
    input: {
        properties: {
            id: { schema: REMOTE_ID_SCHEMA },
        },
    },
    access: {
        permission: &Permission::Privilege(&["resource"], PRIV_RESOURCE_MODIFY, false),
    },
)]
/// List all the remotes this instance is managing.
pub fn remove_remote(id: String) -> Result<(), Error> {
    let (mut remotes, _) = pdm_config::remotes::config()?;

    if remotes.remove(&id).is_none() {
        http_bail!(NOT_FOUND, "no such entry {id:?}");
    }

    pdm_config::remotes::save_config(&remotes)?;

    Ok(())
}

#[api(
    input: {
        properties: {
            id: { schema: REMOTE_ID_SCHEMA },
        },
    },
    returns: { type: pve_api_types::VersionResponse },
    access: {
        permission: &Permission::Privilege(&["resource", "{id}"], PRIV_RESOURCE_AUDIT, false),
    },
)]
/// Query the remote's version.
///
/// FIXME: Should we add an option to explicitly query the entire cluster to get a full version
/// overview?
pub async fn version(id: String) -> Result<pve_api_types::VersionResponse, Error> {
    let (remotes, _) = pdm_config::remotes::config()?;

    let remote = get_remote(&remotes, &id)?;
    match remote.ty {
        RemoteType::Pve => Ok(connection::make_pve_client(remote)?.version().await?),
        RemoteType::Pbs => Ok(connection::make_pbs_client(remote)?.version().await?),
    }
}

#[api(
    input: {
        properties: {
            id: { schema: REMOTE_ID_SCHEMA },
        },
    },
    returns: { type: Remote },
    access: {
        permission: &Permission::Privilege(&["resource", "{id}"], PRIV_RESOURCE_AUDIT, false),
    },
)]
/// Get the Remote Configuration
pub fn remote_config(id: String) -> Result<Remote, Error> {
    let (remotes, _) = pdm_config::remotes::config()?;
    let mut remote = get_remote(&remotes, &id)?.clone();
    // FIXME: proper type here?
    remote.token = String::new(); // mask token in response
    Ok(remote.clone())
}

impl DataPoint for RemoteDatapoint {
    fn new(time: u64) -> Self {
        Self {
            time,
            ..Default::default()
        }
    }

    fn fields() -> &'static [&'static str] {
        &["metric-collection-response-time"]
    }

    fn set_field(&mut self, name: &str, value: f64) {
        if name == "metric-collection-response-time" {
            self.metric_collection_response_time = Some(value);
        }
    }
}

#[api(
    input: {
        properties: {
            id: {
                schema: REMOTE_ID_SCHEMA,
            },
            timeframe: {
                type: RrdTimeframe,
            },
            cf: {
                type: RrdMode,
            },
        },
    },
)]
/// Read metric collection RRD data.
fn get_per_remote_rrd_data(
    id: String,
    timeframe: RrdTimeframe,
    cf: RrdMode,
) -> Result<Vec<RemoteDatapoint>, Error> {
    let base = format!("remotes/{id}");
    rrd_common::create_datapoints_from_rrd(&base, timeframe, cf)
}
